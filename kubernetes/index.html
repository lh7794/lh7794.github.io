<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="lihao">
  
  
  
  
  
  <link rel="canonical" href="https://mogeko.github.io/kubernetes/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
            | lihao`s Blog
       
  </title>
  <meta name="title" content=" | lihao`s Blog">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/mogeko.github.io"
    },
    "articleSection" : "",
    "name" : "",
    "headline" : "",
    "description" : "kubernetes核心功能  服务发现与负载均衡 容器自动装箱 存储编排 自动容器恢复 自动发布与回滚 配置与密文管理 批量执行 水平伸缩  Kubernetes的架构 Kubernetes主要由以下几个核心组件组成：\n etcd保存了整个集群的状态； apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制； controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等； scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上； kubelet负责维护容器的生命周期，同时也负责Volume（CSI）和网络（CNI）的管理； Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）； kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；  除了核心组件，还有一些推荐的插件，其中有的已经成为CNCF中的托管项目：\n CoreDNS负责为整个集群提供DNS服务 Ingress Controller为服务提供外网入口 Prometheus提供资源监控 Dashboard提供GUI Federation提供跨可用区的集群  Kubernetes 架构是一个比较典型的二层架构和 server-client 架构。Master 作为中央的管控节点，会去与 Node 进行一个连接。下面是更为抽象的视图。\nMaster架构  **API Server：**顾名思义是用来处理 API 操作的，Kubernetes 中所有的组件都会和 API Server 进行连接，组件与组件之间一般不进行独立的连接，都依赖于 API Server 进行消息的传送； **Controller：**是控制器，它用来完成对集群状态的一些管理。比如刚刚我们提到的两个例子之中，第一个自动对容器进行修复、第二个自动进行水平扩张，都是由 Kubernetes 中的 Controller 来进行完成的； **Scheduler：**是调度器，“调度器”顾名思义就是完成调度的操作，就是我们刚才介绍的第一个例子中，把一个用户提交的 Container，依据它对 CPU、对 memory 请求大小，找一台合适的节点，进行放置； **etcd：**是一个分布式的一个存储系统，API Server 中所需要的这些原信息都被放置在 etcd 中，etcd 本身是一个高可用系统，通过 etcd 保证整个 Kubernetes 的 Master 组件的高可用性。  Node架构  Pod: Pod是Kubernetes管理的最小单位，Kubernetes不会对容器直接操作，Pod和容器是什么关系呢？Pod可以包括一个或多个容器，每个Pod都有自己的namespace(网络、存储等资源)，在一个Pod内部的多个容器之间关系类似系统间的进程之间关系，使用网络直接用localhost就可以通信。 kubelet: kubelet负责管理pods和它们上面的容器，images镜像、volumes等。 kube-proxy: 每一个节点也运行一个简单的网络代理和负载均衡，例如创建service资源需要kube-proxy。 fluentd: 日志收集工具  kubernetes的服务发现机制 ​\t任何分布式系统都会涉及“服务发现”这个基础问题，大部分分布式系统都通过提供特定的API接口来实现服务发现功能，但这样做会导致平台的侵入性比较强，也增加了开发、测试的难度。Kubernetes则采用了直观朴素的思路去解决这个棘手的问题。",
    "inLanguage" : "zh-cn",
    "author" : "lihao",
    "creator" : "lihao",
    "publisher": "lihao",
    "accountablePerson" : "lihao",
    "copyrightHolder" : "lihao",
    "copyrightYear" : "0001",
    "datePublished": "0001-01-01 00:00:00 \x2b0000 UTC",
    "dateModified" : "0001-01-01 00:00:00 \x2b0000 UTC",
    "url" : "https:\/\/mogeko.github.io\/kubernetes\/",
    "wordCount" : "161",
    "keywords" : [  "lihao`s Blog"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://mogeko.github.io">lihao`s Blog</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://mogeko.github.io">lihao`s Blog</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<div class="post-warp archive">
    <h2 class="post-title" style="text-align:right;padding-bottom:2em"></h2>
    <div class="post-content">
        <h3 id="kubernetes核心功能">kubernetes核心功能</h3>
<ul>
<li>服务发现与负载均衡</li>
<li>容器自动装箱</li>
<li>存储编排</li>
<li>自动容器恢复</li>
<li>自动发布与回滚</li>
<li>配置与密文管理</li>
<li>批量执行</li>
<li>水平伸缩</li>
</ul>
<h3 id="kubernetes的架构">Kubernetes的架构</h3>
<p><img src="https://jimmysong.io/kubernetes-handbook/images/architecture.png" alt=""></p>
<p>Kubernetes主要由以下几个核心组件组成：</p>
<ul>
<li>etcd保存了整个集群的状态；</li>
<li>apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；</li>
<li>controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li>
<li>scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；</li>
<li>kubelet负责维护容器的生命周期，同时也负责Volume（CSI）和网络（CNI）的管理；</li>
<li>Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）；</li>
<li>kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；</li>
</ul>
<p>除了核心组件，还有一些推荐的插件，其中有的已经成为CNCF中的托管项目：</p>
<ul>
<li>CoreDNS负责为整个集群提供DNS服务</li>
<li>Ingress Controller为服务提供外网入口</li>
<li>Prometheus提供资源监控</li>
<li>Dashboard提供GUI</li>
<li>Federation提供跨可用区的集群</li>
</ul>
<p>Kubernetes 架构是一个比较典型的二层架构和 server-client 架构。Master 作为中央的管控节点，会去与 Node 进行一个连接。下面是更为抽象的视图。</p>
<h4 id="master架构">Master架构</h4>
<p><img src="https://jimmysong.io/kubernetes-handbook/images/kubernetes-master-arch.png" alt=""></p>
<ul>
<li>**API Server：**顾名思义是用来处理 API 操作的，Kubernetes 中所有的组件都会和 API Server 进行连接，组件与组件之间一般不进行独立的连接，都依赖于 API Server 进行消息的传送；</li>
<li>**Controller：**是控制器，它用来完成对集群状态的一些管理。比如刚刚我们提到的两个例子之中，第一个自动对容器进行修复、第二个自动进行水平扩张，都是由 Kubernetes 中的 Controller 来进行完成的；</li>
<li>**Scheduler：**是调度器，“调度器”顾名思义就是完成调度的操作，就是我们刚才介绍的第一个例子中，把一个用户提交的 Container，依据它对 CPU、对 memory 请求大小，找一台合适的节点，进行放置；</li>
<li>**etcd：**是一个分布式的一个存储系统，API Server 中所需要的这些原信息都被放置在 etcd 中，etcd 本身是一个高可用系统，通过 etcd 保证整个 Kubernetes 的 Master 组件的高可用性。</li>
</ul>
<h4 id="node架构">Node架构</h4>
<p><img src="https://jimmysong.io/kubernetes-handbook/images/kubernetes-node-arch.png" alt=""></p>
<ul>
<li><strong>Pod:</strong> Pod是Kubernetes管理的最小单位，Kubernetes不会对容器直接操作，Pod和容器是什么关系呢？Pod可以包括一个或多个容器，每个Pod都有自己的namespace(网络、存储等资源)，在一个Pod内部的多个容器之间关系类似系统间的进程之间关系，使用网络直接用localhost就可以通信。</li>
<li><strong>kubelet:</strong> kubelet负责管理pods和它们上面的容器，images镜像、volumes等。</li>
<li><strong>kube-proxy:</strong> 每一个节点也运行一个简单的网络代理和负载均衡，例如创建service资源需要kube-proxy。</li>
<li><strong>fluentd:</strong> 日志收集工具</li>
</ul>
<h3 id="kubernetes的服务发现机制">kubernetes的服务发现机制</h3>
<p>​	任何分布式系统都会涉及“服务发现”这个基础问题，大部分分布式系统都通过提供特定的API接口来实现服务发现功能，但这样做会导致平台的侵入性比较强，也增加了开发、测试的难度。Kubernetes则采用了直观朴素的思路去解决这个棘手的问题。</p>
<p>​	首先，每个Kubernetes中的Service都有唯一的Cluster IP及唯一的名称，而名称是由开发者自己定义的，部署时也没必要改变，所以完全可以被固定在配置中。接下来的问题就是如何通过Service的名称找到对应的Cluster IP。</p>
<p>​	最早时Kubernetes采用了Linux 环境变量（ENV），并在每个Pod的容器启动时自动注入这些环境变量。每个Service的IP地址及端口都有标准的命名规范，遵循这个命名规范，就可以通过代码访问系统环境变量来得到所需的信息，实现服务调用。</p>
<p>​	考虑到通过环境变量获取Service地址的方式仍不太方便、不够直观，后来Kubernetes通过Add-On增值包引入了DNS系统，把服务名作为DNS域名，这样程序就可以直接使用服务名来建立通信连接了。目前，Kubernetes上的大部分应用都已经采用了DNS这种新兴的服务发现机制。</p>
<h3 id="kubernetes的负载均衡机制">Kubernetes的负载均衡机制</h3>
<p>​	Kubernetes在设计之初就充分考虑了针对容器的服务发现与负载均衡机制，提供了Service资源，并通过kube-proxy配合cloud provider来适应不同的应用场景。随着Kubernetes用户的激增，用户场景的不断丰富，又产生了一些新的负载均衡机制。目前，Kubernetes中的负载均衡大致可以分为以下几种机制，每种机制都有其特定的应用场景：</p>
<ul>
<li><strong>Service</strong>：直接用Service提供cluster内部的负载均衡，并借助cloud provider提供的LB提供外部访问</li>
<li><strong>Ingress</strong>：还是用Service提供cluster内部的负载均衡，但是通过自定义LB提供外部访问</li>
<li><strong>Service Load Balancer</strong>：把load balancer直接跑在容器中，实现Bare Metal的Service Load Balancer</li>
<li><strong>Custom Load Balancer</strong>：自定义负载均衡，并替代kube-proxy，一般在物理部署Kubernetes时使用，方便接入公司已有的外部服务</li>
</ul>
<h3 id="容器自动装箱">容器自动装箱</h3>
<p>​	容器的自动装箱，我们也会把它叫做 scheduling，就是“调度”，把一个容器放到一个集群的某一个机器上，Kubernetes 会帮助我们去做存储的编排，让存储的声明周期与容器的生命周期能有一个连接。</p>
<p>​	Pod调度控制器：全自动调度、定向调度、Node亲和性调度、Pod亲和与互斥调度策略······等各种调度策略，甚至Kubernetes支持自定义调度器，用户可以使用自己开发的调度器进行调度。</p>
<p>​	Deployment或RC的主要功能之一就是自动部署一个容器应用的多份副本，以及持续监控副本的数量，在集群内始终维持用户指定的副本数量。</p>
<h3 id="自动发布与回滚">自动发布与回滚</h3>
<p>​</p>
<h3 id="批量执行">批量执行</h3>
<p>​	Kubernetes从1.2版本开始支持批处理类型的应用，我们可以通过Kubernetes Job资源对象来定义并启动一个批处理任务。批处理任务通常并行（或者串行）启动多个计算进程去处理一批工作项（work item），处理完成后，整个批处理任务结束。按照批处理任务实现方式的不同，批处理任务可以分为以下几种模式。</p>
<ul>
<li>Job Template Expansion模式：一个Job对象对应一个待处理的Work item，有几个Work item就产生几个独立的Job，通常适合Work item数量少、每个Work item要处理的数据量比较大的场景。</li>
<li>Queue with Pod Per Work item模式：采用一个任务队列存放Work item，一个Job对象作为消费者去完成这些Work item，在这种模式下，Job会启动N个Pod，每个Pod都对应一个Work item。</li>
<li>Queue with Variable Pod Per Count模式：采用一个任务队列存放Work item，一个Job对象作为消费者去完成这些Work item，但与上面的模式不同，Job启动的Pod数量是可变的。</li>
</ul>
<h3 id="自动容器恢复">自动容器恢复</h3>
<p>​	Kubernetes 有一个节点健康检查的功能，它会监测这个集群中所有的宿主机，当宿主机本身出现故障，或者软件出现故障的时候，这个节点健康检查会自动对它进行发现。</p>
<h3 id="水平伸缩">水平伸缩</h3>
<p>​	在实际生产系统中，我们经常会遇到某个服务需要扩容的场景，也可能会遇到由于资源紧张或者工作负载降低而需要减少服务实例数量的场景。此时可以利用Deployment/RC的Scale机制来完成这些工作。</p>
<p>​	Kubernetes对Pod的扩缩容操作提供了手动和自动两种模式，手动模式通过执行kubectl scale命令或通过RESTful API对一个Deployment/RC进行Pod副本数量的设置，即可一键完成。自动模式则需要用户根据某个性能指标或者自定义业务指标，并指定Pod副本数量的范围，系统将自动在这个范围内根据性能指标的变化进行调整。</p>
<p>​	自动扩缩容机制：Kubernetes从1.1版本开始，新增了名为Horizontal Pod Autosacler（HPA）的控制器，用于实现基于CPU使用率进行自动Pod扩缩容的功能。HPA控制器基于Master的kube-controller-manager服务启动参数&ndash;horizontal-pod-autosacler-sync-period定义的探测周期（默认值为15s），周期性地监测目标Pod地资源性能指标，并于HPA资源对象中地扩缩容条件进行对比，在满足条件时对Pod副本数量进行调整。</p>

    </div>
</div>

          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2017 - 2020</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://mogeko.github.io">lihao</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
